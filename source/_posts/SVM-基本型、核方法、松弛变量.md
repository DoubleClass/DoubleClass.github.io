---
title: SVM(基本型、核方法、松弛变量)
date: 2020-04-13 17:14:37
tags:
- 机器学习
---

## 写在前面

在前面介绍过拉格朗日法处理不等式约束的优化问题后，我们就可以回过头再重新看一看SVM，这篇文章将对SVM常出现的几个概念进行简要的介绍。

参考文章：

http://www.blogjava.net/zhenandaci/category/31868.html

https://www.jiqizhixin.com/articles/2018-10-17-20

## SVM概述

### 官方描述

支持向量机方法是建立在统计学习理论的VC 维理论和结构风险最小原理基础上的，根据有限的样本信息在模型的复杂性（即对特定训练样本的学习精度，Accuracy）和学习能力（即无错误地识别任意样本的能力）之间寻求最佳折衷，以期获得最好的推广能力（泛化能力）。

下面就详细讲一讲这几项都是说的啥。

### 统计学习理论

统计机器学习之所以区别于传统机器学习的本质，就在于统计机器学习能够精确的给出学习效果，能够解答需要的样本数等等一系列问题。与统计机器学习的精密思维相比，传统的机器学习基本上属于摸着石头过河，用传统的机器学习方法构造分类系统完全成了一种技巧，一个人做的结果可能很好，另一个人差不多的方法做出来却很差，缺乏指导和原则。

### VC维理论

所谓VC维是对函数类的一种度量，可以简单的理解为问题的复杂程度，VC维越高，一个问题就越复杂。正是因为SVM关注的是VC维，后面我们可以看到，SVM解决问题的时候，和样本的维数是无关的（甚至样本是上万维的都可以，这使得SVM很适合用来解决文本分类的问题，当然，有这样的能力也因为引入了核函数）。

### 结构风险

机器学习本质上就是一种对问题真实模型的逼近（我们选择一个我们认为比较好的近似模型，这个近似模型就叫做一个假设），但毫无疑问，真实模型一定是不知道的（如果知道了，我们干吗还要机器学习？直接用真实模型解决问题不就可以了？对吧，哈哈）既然真实模型不知道，那么我们选择的假设与问题真实解之间究竟有多大差距，我们就没法得知。比如说我们认为宇宙诞生于150亿年前的一场大爆炸，这个假设能够描述很多我们观察到的现象，但它与真实的宇宙模型之间还相差多少？谁也说不清，因为我们压根就不知道真实的宇宙模型到底是什么。

这个与问题真实解之间的误差，就叫做风险（更严格的说，误差的累积叫做风险）。我们选择了一个假设之后（更直观点说，我们得到了一个分类器以后），真实误差无从得知，但我们可以用某些可以掌握的量来逼近它。最直观的想法就是使用分类器在样本数据上的分类的结果与真实结果（因为样本是已经标注过的数据，是准确的数据）之间的差值来表示。这个差值叫做经验风险Remp(w)。以前的机器学习方法都把经验风险最小化作为努力的目标，但后来发现很多分类函数能够在样本集上轻易达到100%的正确率，在真实分类时却一塌糊涂（即所谓的推广能力差，或泛化能力差）。此时的情况便是选择了一个足够复杂的分类函数（它的VC维很高），能够精确的记住每一个样本，但对样本之外的数据一律分类错误。回头看看经验风险最小化原则我们就会发现，此原则适用的大前提是经验风险要确实能够逼近真实风险才行（行话叫一致），但实际上能逼近么？答案是不能，因为样本数相对于现实世界要分类的文本数来说简直九牛一毛，经验风险最小化原则只在这占很小比例的样本上做到没有误差，当然不能保证在更大比例的真实文本上也没有误差。

统计学习因此而引入了泛化误差界的概念，就是指真实风险应该由两部分内容刻画，一是经验风险，代表了分类器在给定样本上的误差；二是置信风险，代表了我们在多大程度上可以信任分类器在未知文本上分类的结果。很显然，第二部分是没有办法精确计算的，因此只能给出一个估计的区间，也使得整个误差只能计算上界，而无法计算准确的值（所以叫做泛化误差界，而不叫泛化误差）。

置信风险与两个量有关，一是样本数量，显然给定的样本数量越大，我们的学习结果越有可能正确，此时置信风险越小；二是分类函数的VC维，显然VC维越大，推广能力越差，置信风险会变大。

泛化误差界的公式为：

![image-20200413184057251](https://i.loli.net/2020/04/13/9YSTlHhjsXw4Bx8.png)

公式中R(w)就是真实风险，Remp(w)就是经验风险，Ф(n/h)就是置信风险。统计学习的目标从经验风险最小化变为了寻求经验风险与置信风险的和最小，即结构风险最小。

SVM正是这样一种努力最小化结构风险的算法。

## SVM基本型

### 线性分类器

线性分类器(一定意义上,也可以叫做感知机) 是最简单也很有效的分类器形式.在一个线性分类器中,可以看到SVM形成的思路,并接触很多SVM的核心概念.

用一个二维空间里仅有两类样本的分类问题来举个小例子。如图所示

![image-20200413184432460](https://i.loli.net/2020/04/13/zX1YQgGspnWLxoE.png)

C1和C2是要区分的两个类别，在二维平面中它们的样本如上图所示。中间的直线就是一个分类函数，它可以将两类样本完全分开。一般的，如果一个线性函数能够将样本完全正确的分开，就称这些数据是线性可分的，否则称为非线性可分的。

什么叫线性函数呢？在一维空间里就是一个点，在二维空间里就是一条直线，三维空间里就是一个平面，可以如此想象下去，如果不关注空间的维数，这种线性函数还有一个统一的名称——超平面（Hyper Plane）！

实际上，一个线性函数是一个实值函数（即函数的值是连续的实数），而我们的分类问题（例如这里的二元分类问题——回答一个样本属于还是不属于一个类别的问题）需要离散的输出值，例如用1表示某个样本属于类别C1，而用0表示不属于（不属于C1也就意味着属于C2），这时候只需要简单的在实值函数的基础上附加一个阈值即可，通过分类函数执行时得到的值大于还是小于这个阈值来确定类别归属。 例如我们有一个线性函数
$$
g(x)=wx+b
$$
我们可以取阈值为0，这样当有一个样本xi需要判别的时候，我们就看g(xi)的值。若g(xi)>0，就判别为类别C1，若g(xi)<0，则判别为类别C2（等于的时候我们就拒绝判断，haha）。此时也等价于给函数g(x)附加一个符号函数sign()，即f(x)=sign [g(x)]是我们真正的判别函数。

关于$$g(x)=wx+b$$这个表达式要注意三点：

1. 式中的x不是二维坐标系中的横轴，而是样本的向量表示
2. 这个形式并不局限于二维的情况，在n维空间中仍然可以使用这个表达式，只是式中的w成为了n维向量
3. g(x)不是中间那条直线的表达式，中间那条直线的表达式是g(x)=0，即wx+b=0，我们也把这个函数叫做分类面。

实际上很容易看出来，中间那条分界线并不是唯一的，我们把它稍微旋转一下，只要不把两类数据分错，仍然可以达到上面说的效果，稍微平移一下，也可以。此时就牵涉到一个问题，对同一个问题存在多个分类函数的时候，哪一个函数更好呢？

显然我们必须要先找一个指标来量化“好”的程度，通常使用的都是叫做“分类间隔”的指标。

### 找到更好的分类器

我们定义一个样本点到某个超平面的间隔：
$$
δ_i=y_i(w·x_i+b)
$$
仔细观察这个式子，我们可以知道这个间隔总是大于零的，而且它的值就等于|wxi+b|！（也就是|g(xi)|），我们把w和b进行一下归一化，即用w/||w||和b/||w||分别代替原来的w和b，那么间隔就可以写成

![image-20200413185846260](https://i.loli.net/2020/04/13/vTx3tRy8XwFSebj.png)

（点到直线的距离，做解析几何中为： $$D = \frac{(Ax + By + c)}{\sqrt{(A^2+B^2)}}$$  $$\sqrt{(A^2+B^2)}$$就相当于||W||, 其中向量W=[A, B]; $$(Ax + By + c)$$就相当于g(X), 其中向量X=[x,y]。）

这个公式是不是看上去有点眼熟？没错，这不就是解析几何中点xi到直线g(x)=0的距离公式嘛！（推广一下，是到超平面g(x)=0的距离， g(x)=0就是上节中提到的分类超平面）

同时，如果你有阅读过周志华老师的西瓜书，书上对“间隔”的描述正是这样：

![image-20200413190754648](https://i.loli.net/2020/04/13/GytzXZVa2Txb5Lw.png)

现在就可以给出问题的基本型啦，我们要做的就是最大化这个间隔，同时满足对现有样本分类正确：

![image-20200413191025140](https://i.loli.net/2020/04/13/RA6HXmNdtZMgoy1.png)

这里我们可以稍微停顿一下，稍微思考一下，如果没有这个约束，那么$w$直接取0就好了嘛，这对应什么情况呢，对应着，对每一个给定的要分类的样本，分类器只能给出一个结果，就是b，这也就完全失去了分类器的意义，所以，很重要的问题是，如何在有约束的条件下求解这个优化问题。

## SVM的求解

我们在上面的文章中已经给出了拉格朗日乘子法，所以这里不作过多介绍，我们直接算起来。

这里我们分两部分，第一部分从感性上理解这个求解过程，第二部分从求导上看看第一部分的结果是怎么得到的。

### 理解

首先我们再次祭出问题模型图：

![image-20200413191755782](https://i.loli.net/2020/04/13/MV6ADB8WOGxgo3P.png)

我们有属于两个类别的样本点（并不限定这些点在二维空间中）若干，如上图，圆形的样本点定为正样本（连带着，我们可以把正样本所属的类叫做正类），方形的点定为负例。我们想求得这样一个线性函数（在n维空间中的线性函数）：
$$
g(x)=wx+b
$$

使得所有属于正类的点+代入以后有g(x+)≥1，而所有属于负类的点x-代入后有g(x-)≤-1（之所以总跟1比较，无论正一还是负一，都是因为我们固定了间隔为1）。代入g(x)后的值如果在1和-1之间，我们就拒绝判断。

求这样的g(x)的过程就是求w（一个n维向量）和b（一个实数）两个参数的过程（但实际上只需要求w，求得以后找某些样本点代入就可以求得b）。因此在求g(x)的时候，w才是变量。

你肯定能看出来，一旦求出了w（也就求出了b），那么中间的直线H就知道了（因为它就是wx+b=0嘛，哈哈），那么H1和H2也就知道了（因为三者是平行的，而且相隔的距离还是||w||决定的）。那么w是谁决定的？显然是你给的样本决定的，一旦你在空间中给出了那些个样本点，三条直线的位置实际上就唯一确定了（因为我们求的是最优的那三条，当然是唯一的），我们解优化问题的过程也只不过是把这个确定了的东西算出来而已。

样本确定了w，用数学的语言描述，就是w可以表示为样本的某种组合：
$$
w = \alpha_1x_1 +\alpha_2x_2+...+\alpha_nx_n
$$
式子中的αi是一个一个的数（在严格的证明过程中，这些α被称为拉格朗日乘子），而xi是样本点，因而是向量，n就是总样本点的个数。为了方便描述，以下开始严格区别数字与向量的乘积和向量间的乘积，我会用α1x1表示数字和向量的乘积，而用<x1,x2>表示向量x1,x2的内积（也叫点积，注意与向量叉积的区别）。因此g(x)的表达式严格的形式应该是：
$$
g(x) = <x,w>+b
$$
但是上面的式子还不够好，你回头看看图中正样本和负样本的位置，想像一下，我不动所有点的位置，而只是把其中一个正样本点定为负样本点（也就是把一个点的形状从圆形变为方形），结果怎么样？三条直线都必须移动（因为对这三条直线的要求是必须把方形和圆形的点正确分开）！这说明w不仅跟样本点的位置有关，还跟样本的类别有关（也就是和样本的“标签”有关）。因此用下面这个式子表示才算完整：
$$
w = \alpha_1y_1x_1 +\alpha_2y_2x_2+...+\alpha_ny_nx_n
$$
其中的yi就是第i个样本的标签，它等于1或者-1。其实以上式子的那一堆拉格朗日乘子中，只有很少的一部分不等于0（不等于0才对w起决定作用），这部分不等于0的拉格朗日乘子后面所乘的样本点，其实都落在H1和H2上，也正是这部分样本（而不需要全部样本）唯一的确定了分类函数，当然，更严格的说，这些样本的一部分就可以确定，因为例如确定一条直线，只需要两个点就可以，即便有三五个都落在上面，我们也不是全都需要。这部分我们真正需要的样本点，就叫做支持（撑）向量！（名字还挺形象吧，他们“撑”起了分界线）

式子也可以用求和符号简写一下：


$$
w = \sum_{i=1}^{n}\alpha_iy_ix_i
$$
哈哈这个式子是不是有些眼熟，这个正是我们下面从求导为零推出来的~

### 求导

问题转为拉格朗日乘子法形式如下：

![image-20200413193301246](https://i.loli.net/2020/04/13/HYPFbkaxcvpJmnS.png)

我们分别对$w$ $b$求导为零，可得：

![image-20200413193817952](https://i.loli.net/2020/04/13/Drsi8MEuzWkqY74.png)

进一步带入，可得：

![image-20200413194014813](E:\hexo\source\_posts\images\image-20200413194014813.png)

问题最终转化为这样一个二次规划问题，而SVM中另一个著名的关键词SMO就是为了解决这个问题，但是这个方法我还没有学会，所以不能在这里分享啦，以后有机会再多了解了解这个方法。

## 方法的优化

讨论进行到这里，我们的SVM仍没有逃出“线性分类器”这个圈，对于线性不可分的样本，依然无能为力，所以，我们需要对模型进行稍微的调整，来解决那些线性不可分的问题：

这里讨论两种最常见的方法，核函数和松弛变量

### 方法一：核函数



我们从一个典型的线性不可分例子开始我们的讨论：

![image-20200413195842207](https://i.loli.net/2020/04/13/GpOyfLmV9KxkIT5.png)

我们把横轴上端点a和b之间红色部分里的所有点定为正类，两边的黑色部分里的点定为负类。试问能找到一个线性函数把两类正确分开么？不能，因为二维空间里的线性函数就是指直线，显然找不到符合条件的直线。

但我们可以找到一条曲线，例如下面这一条：

![image-20200413195907007](https://i.loli.net/2020/04/13/e62FuPHXModyzEf.png)

显然通过点在这条曲线的上方还是下方就可以判断点所属的类别（你在横轴上随便找一点，算算这一点的函数值，会发现负类的点函数值一定比0大，而正类的一定比0小）。这条曲线就是我们熟知的二次曲线，它的函数表达式可以写为：
$$
g(x) = c_0+c_1x+c_2x^2
$$
问题只是它不是一个线性函数，但是，下面要注意看了，新建一个向量y和a：

![image-20200413200008658](https://i.loli.net/2020/04/13/tb1cr9pjYmWJUCL.png)

这样g(x)就可以转化为f(y)=<a,y>，你可以把y和a分别回带一下，看看等不等于原来的g(x)。用内积的形式写你可能看不太清楚，实际上f(y)的形式就是：

g(x)=f(y)=ay

在任意维度的空间中，这种形式的函数都是一个线性函数（只不过其中的a和y都是多维向量罢了），因为自变量y的次数不大于1。

看出妙在哪了么？原来在二维空间中一个线性不可分的问题，映射到四维空间后，变成了线性可分的！因此这也形成了我们最初想解决线性不可分问题的基本思路——向高维空间转化，使其变得线性可分。

而转化最关键的部分就在于找到x到y的映射方法。遗憾的是，如何找到这个映射，没有系统性的方法（也就是说，纯靠猜和凑）。具体到我们的文本分类问题，文本被表示为上千维的向量，即使维数已经如此之高，也常常是线性不可分的，还要向更高的空间转化。其中的难度可想而知。

用一个具体文本分类的例子来看看这种向高维空间映射从而分类的方法如何运作，想象一下，我们文本分类问题的原始空间是1000维的（即每个要被分类的文档被表示为一个1000维的向量），在这个维度上问题是线性不可分的。现在我们有一个2000维空间里的线性函数

$$f(x’)=<w’,x’>+b$$

注意向量的右上角有个 ’哦。它能够将原问题变得可分。式中的 w’和x’都是2000维的向量，只不过w’是定值，而x’是变量（好吧,严格说来这个函数是2001维的,哈哈），现在我们的输入呢，是一个1000维的向量x，分类的过程是先把x变换为2000维的向量x’，然后求这个变换后的向量x’与向量w’的内积，再把这个内积的值和b相加，就得到了结果，看结果大于阈值还是小于阈值就得到了分类结果。

你发现了什么？我们其实只关心那个高维空间里内积的值，那个值算出来了，分类结果就算出来了。而从理论上说， x’是经由x变换来的，因此广义上可以把它叫做x的函数（有一个x，就确定了一个x’，对吧，确定不出第二个），而w’是常量，它是一个低维空间里的常量w经过变换得到的，所以给了一个w 和x的值，就有一个确定的f(x’)值与其对应。这让我们幻想，是否能有这样一种函数K(w,x),他接受低维空间的输入值，却能算出高维空间的内积值<w’,x’>？

如果有这样的函数，那么当给了一个低维空间的输入x以后，

![image-20200413200202900](https://i.loli.net/2020/04/13/STwHUCYyPKR6l4q.png)

这两个函数的计算结果就完全一样，我们也就用不着费力找那个映射关系，直接拿低维的输入往g(x)里面代就可以了（再次提醒，这回的g(x)就不是线性函数啦，因为你不能保证K(w,x)这个表达式里的x次数不高于1哦）。（事实上，这个过程在西瓜书上解释为，直接用高维向量点乘会导致计算量异常巨大

万幸的是，这样的K(w,x)确实存在，它就是被称作核函数（核，kernel）的辣个东西，而且还不止一个，事实上，只要是满足了Mercer条件的函数，都可以作为核函数。核函数的基本作用就是接受两个低维空间里的向量，能够计算出经过某个变换后在高维空间里的向量内积值。

好啦，说完了啥叫核函数，也给大家看看一看那些函数这么神奇，可以做这个事情：

![image-20200413200502050](https://i.loli.net/2020/04/13/TldMfaQn126W3eL.png)

### 方法二：松弛变量

现在我们已经把一个本来线性不可分的文本分类问题，通过映射到高维空间而变成了线性可分的。就像下图这样：

![image-20200413200720825](https://i.loli.net/2020/04/13/W3nCzbEXRaNrtkD.png)

圆形和方形的点各有成千上万个（毕竟，这就是我们训练集中文档的数量嘛，当然很大了）。现在想象我们有另一个训练集，只比原先这个训练集多了一篇文章，映射到高维空间以后（当然，也使用了相同的核函数），也就多了一个样本点，但是这个样本的位置是这样的：

![image-20200413200745278](https://i.loli.net/2020/04/13/QFzdVIp4TkhnZwf.png)

就是图中黄色那个点，它是方形的，因而它是负类的一个样本，这单独的一个样本，使得原本线性可分的问题变成了线性不可分的。这样类似的问题（仅有少数点线性不可分）叫做“近似线性可分”的问题。

以我们人类的常识来判断，说有一万个点都符合某种规律（因而线性可分），有一个点不符合，那这一个点是否就代表了分类规则中我们没有考虑到的方面呢（因而规则应该为它而做出修改）？

其实我们会觉得，更有可能的是，这个样本点压根就是错误，是噪声，是提供训练集的同学人工分类时一打瞌睡错放进去的。所以我们会简单的忽略这个样本点，仍然使用原来的分类器，其效果丝毫不受影响。

但这种对噪声的容错性是人的思维带来的，我们的程序可没有。由于我们原本的优化问题的表达式中，确实要考虑所有的样本点（不能忽略某一个，因为程序它怎么知道该忽略哪一个呢？），在此基础上寻找正负类之间的最大几何间隔，而几何间隔本身代表的是距离，是非负的，像上面这种有噪声的情况会使得整个问题无解。这种解法其实也叫做“硬间隔”分类法，因为他硬性的要求所有样本点都满足和分类平面间的距离必须大于某个值。

因此由上面的例子中也可以看出，硬间隔的分类法其结果容易受少数点的控制，这是很危险的（尽管有句话说真理总是掌握在少数人手中，但那不过是那一小撮人聊以自慰的词句罢了，咱还是得民主）。

但解决方法也很明显，就是仿照人的思路，允许一些点到分类平面的距离不满足原先的要求。由于不同的训练集各点的间距尺度不太一样，因此用间隔（而不是几何间隔）来衡量有利于我们表达形式的简洁。我们原先对样本点的要求是：

![image-20200413200935735](https://i.loli.net/2020/04/13/b3mRfKaXtzIP5l9.png)

意思是说离分类面最近的样本点函数间隔也要比1大。如果要引入容错性，就给1这个硬性的阈值加一个松弛变量，即允许：

![image-20200413201008603](E:\hexo\source\_posts\images\image-20200413201008603.png)

因为松弛变量是非负的，因此最终的结果是要求间隔可以比1小。但是当某些点出现这种间隔比1小的情况时（这些点也叫离群点），意味着我们放弃了对这些点的精确分类，而这对我们的分类器来说是种损失。但是放弃这些点也带来了好处，那就是使分类面不必向这些点的方向移动，因而可以得到更大的几何间隔（在低维空间看来，分类边界也更平滑）。显然我们必须权衡这种损失和好处。好处很明显，我们得到的分类间隔越大，好处就越多。回顾我们原始的硬间隔分类对应的优化问题：

![image-20200413201052535](https://i.loli.net/2020/04/13/9MCHNZqFjXUTuGW.png)

||w||2就是我们的目标函数（当然系数可有可无），希望它越小越好，因而损失就必然是一个能使之变大的量（能使它变小就不叫损失了，我们本来就希望目标函数值越小越好）。那如何来衡量损失，有很多方式，西瓜书也给出几种常用的损失函数：

![image-20200413201533356](https://i.loli.net/2020/04/13/85zwHoEahWju9Kf.png)

对于具体问题，需要考虑不同的损失函数，没有确切的说法哪一个比较实用。

### 综合

那可能有同学会问，两个方法都是为了解决线性不可分问题，那我们要怎么选择呢？是两个都要用，还是咋样呢？

其实这两种方法还是有些许不同，一般的过程应该是这样，还以文本分类为例。在原始的低维空间中，样本相当的不可分，无论你怎么找分类平面，总会有大量的离群点，此时用核函数向高维空间映射一下，虽然结果仍然是不可分的，但比原始空间里的要更加接近线性可分的状态（就是达到了近似线性可分的状态），此时再用松弛变量处理那些少数“冥顽不化”的离群点，就简单有效得多啦。

## 写在最后

其实关于SVM还是留下了两个话题没有讨论，一个是，为什么拉格朗日法，先求对w和b的最小值，再求对$\alpha$的最大值就能得到问题解了呢？

另一个是SMO方法，也是没有搞懂，留到后面去吧，今天就到这里啦。